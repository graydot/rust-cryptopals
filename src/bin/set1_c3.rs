
fn main() {
    let (plain_text, code, _score) = decrypt("1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736");
    println!("Result: {}, Code: {}", plain_text, code);
}
/// Given a hex representation of a string, return a tuple with the highest ranked
/// String generated by XORing with different characters
pub fn decrypt(hex_string: &str) -> (String, char, i32) {
    let mut max_score: i32 = 0;
    let mut result: String = "".to_string();
    let mut code = ' ';
    
    let ascii_str = hex_to_ascii(hex_string);
    for ch in (b'A'..b'Z').chain(b'0'..b'9') {
        let plain_text = xor(&ascii_str, ch as char);
        // Use the new score function to solve puzzle 4
        let score_val: i32 = score(&plain_text);
        if score_val > max_score {
            result = plain_text;
            max_score = score_val;
            code = ch as char;
        }
    }

    (result, code, max_score)
}

pub fn xor(encrypted: &str, code: char) -> String{
    
    let result = encrypted.chars().map(|a|
    {
        xor_char(a, code)
    }).collect();
    result
}

pub fn xor_char(text: char, code: char) -> char {
    (text as u8 ^ code as u8) as char
}

/// Returns the ASCII String when provided a hex representation of the string
pub fn hex_to_ascii(hex_str: &str) -> String {
    let mut chars = hex_str.chars();
    // FIXME: may fail if len is not even.
    let mut return_string = String::new();
    while chars.size_hint().0 > 0 {
        let hex1: u8 = match chars.next() {
            Some(ch) => match ch.to_digit(16) {
                Some(val) => val as u8,
                None => 0,
            },
            None => 0
        };
        let hex2: u8 = match chars.next() {
            Some(ch) => match ch.to_digit(16) {
                Some(val) => val as u8,
                None => 0,
            },
            None => 0
        };
        let ascii_val = hex1 * u8::pow(2, 4) + hex2;
        return_string.push(ascii_val as char);
    }
        
    
    return_string
}

pub fn score(plain_text: &String) -> i32 {
    let mut ascii_score = 0;
    let mut non_ascii_score = 0;
    for ch in plain_text.chars() { 
        if ch.is_ascii_alphabetic() {
            ascii_score += 1;
        }
    };
    ascii_score - non_ascii_score
}

pub fn score_etaoin_shrdlu(text: &String) -> i32 {
    let mut score = 0;
    let lower_text = text.to_ascii_lowercase();
    let lower_etaoin_shrldu = "etaoinshrldu";
    for ch in lower_text.chars() {
        if lower_etaoin_shrldu.contains(ch) {
            score += 1;
        }
    }
    score
}

#[cfg(test)]
mod test {
    use super::*;
}